{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Benvenuto su Downtime Panda!","text":"<p>Figure 1: Downtime Panda Logo</p> <p>Questa \u00e8 la documentazione di Downtime Panda, un progetto ispirato ad Uptime Kuma e sviluppato per il corso di \"Sicurezza negli Ambienti Orientati ai Servizi\" tenuto all'Universit\u00e0 degli Studi di Bari \"Aldo Moro\".</p> <p>Questa documentazione \u00e8 prodotta grazie a mkdocs.org.</p>"},{"location":"1-developer-guide/","title":"Guida allo sviluppo","text":"<p>In questa sezione \u00e8 illustrato il setup del progetto per lo sviluppo</p>"},{"location":"1-developer-guide/#setup-in-breve","title":"Setup in breve","text":"<p>Clona il progetto da github</p> <pre><code>git clone https://github.com/Mikel12455/downtime-panda.git\n</code></pre> <p>Poi, metti su l'ambiente virtuale</p> <pre><code>cd downtime-panda\ntask setup\n</code></pre> <p>Se non ho Taskfile?</p> <p>Se non hai Taskfile installato, puoi invece seguire questi comandi:</p> <pre><code>cd downtime-panda\nuv sync --all-packages\nuv run pre-commit install\n</code></pre> <p>In questo modo avrai lo stesso setup del comando di sopra, ma come extra avrai Task installato direttamente nel tuo ambiente virtuale!</p> <p>Ricordati giusto che ti servir\u00e0 uv per richiamare le task. In sostanza, invece del comando</p> <pre><code>task do-something\n</code></pre> <p>dovrai usare</p> <pre><code>uv run task do-something\n</code></pre>"},{"location":"1-developer-guide/#sviluppo","title":"Sviluppo","text":"<p>Messo su l'ambiente virtuale, fai partire il progetto nell'ambiente di sviluppo tramite</p> <pre><code>task dev-up\n</code></pre> <p>Da un browser vai su <code>https://localhost:8080/</code> per vedere le modifiche che apporti al codice in tempo reale!</p>"},{"location":"1-developer-guide/#staging","title":"Staging","text":"<p>Se vuoi fare qualche test pi\u00f9 reale, completo di database PostgreSQL e di Reverse Proxy, usa questo comando</p> <pre><code>task staging-up\n</code></pre> <p>Questo costruir\u00e0 un container Docker del progetto, e lo metter\u00e0 su tramite <code>docker compose up</code></p>"},{"location":"1-developer-guide/#dipendenze","title":"Dipendenze","text":"<p>Le uniche vere dipendenze richieste per sviluppare sul progetto sono:</p> <ul> <li><code>uv</code>, per la gestione del progetto (specialmente le sue dipendenze)</li> <li>Docker, ma solo per lo staging</li> </ul> <p>Il progetto fa comunque uso di altri programmi per lo sviluppo, ma sono tutti inclusi nell'ambiente virtuale gestito da <code>uv</code></p> <ul> <li> <p><code>pre-commit</code>: Configura dei git hook per cose come linter, formatter, e in generale controlli del sorgente prima di una commit.</p> <ul> <li>Incluso tra le dipendenze <code>--dev</code>, quindi non serve installarlo globalmente</li> </ul> </li> <li> <p><code>mkdocs</code>: Costruisce la documentazione che stai leggendo adesso ;)</p> <ul> <li>Incluso tra le dipendenze <code>--dev</code>, assieme ad altri suoi plugin</li> </ul> </li> <li> <p><code>Taskfile</code>:</p> <ul> <li> <p>Se non lo avete installato globalmente, si pu\u00f2 installare nell'ambiente virtuale del progetto tramite</p> <pre><code>uv sync --group task\n</code></pre> <p>L'unica cosa \u00e8 che invece di usare <code>task &lt;un_task&gt;</code> si deve usare <code>uv run task &lt;un_task&gt;</code></p> </li> </ul> </li> </ul>"},{"location":"2-architecture/","title":"Architettura","text":"<p>In questa sezione \u00e8 illustrato tutto quanto riguardi l'architettura ed il funzionamento del progetto.</p>"},{"location":"2-architecture/#organizzazione-del-sorgente","title":"Organizzazione del sorgente","text":"<p>Il progetto \u00e8 organizzato in una serie di cartelle e moduli con l'obiettivo di suddividerlo in modo \"verticale\", ovvero dividerlo per funzionalit\u00e0.</p>"},{"location":"2-architecture/#moduli-principali","title":"Moduli principali","text":"<p>I moduli non contenuti in <code>blueprints</code> fanno principalmente da configurazione dell'applicazione Flask.</p> <ul> <li><code>__init__.py</code>: Contiene la funzione <code>create_app</code>, che fa da \"application factory\" per Flask.</li> <li><code>extensions.py</code>: Inizializza tutte le estensioni Flask usate per tutta l'applicazione</li> <li><code>config.py</code>: Contiene le classi per configurare l'applicazione a partire dai valori nelle variabili d'ambiente.</li> </ul>"},{"location":"2-architecture/#blueprint","title":"Blueprint","text":"<p>Ogni pacchetto Python sotto la cartella <code>blueprints</code> contiene, al suo interno, diversi moduli con tutto quello che serve per implementare la relativa funzionalit\u00e0:</p> <ul> <li><code>routes.py</code>: Rotte Flask della relativa funzionalit\u00e0</li> <li><code>messages.py</code>: Messaggi di feedback inviati all'utente per quando fa qualcosa (Ex. credenziali non valide durante il login).</li> <li><code>forms.py</code>: Tutti i form utili al modulo, implementati tramite Flask-WTF.</li> <li><code>api.py</code>: Rotte per servire l'API esposta dalla funzionalit\u00e0.</li> <li><code>models.py</code>: Modelli per interfacciarsi con il database.</li> </ul> <p>I template Jinja di ogni blueprint \u00e8 incluso nella cartella <code>templates</code>. La struttura delle cartelle \u00e8 la stessa seguita in <code>blueprints</code>.</p>"},{"location":"2-architecture/#schema-e-r","title":"Schema E-R","text":"<p>Il database usato da Downtime Panda \u00e8 riassunto nello schema seguente.</p> <p>Figure 1: Entity Relationship Diagram</p> <p>Sulla colonna <code>ID</code> ...</p> <p>Senza doverlo ripetere in ogni entit\u00e0, la colonna <code>ID</code> di ognuna delle entit\u00e0 \u00e8 un intero a 8 byte autogenerato.</p> <p>La scelta di usare un intero a 8 byte sta nella tabella <code>Ping</code>, che nel tempo si riempir\u00e0 di numerosi ping dai pi\u00f9 disparati servizi; questo porter\u00e0 inevitabilmente a superare il massimo numero di valori possibili per un tipico intero a 4 byte (circa ~4.000.000.000, dimezzati se non si vogliono usare i valori negativi).</p> <p>Si poteva probabilmente evitare per le altre entit\u00e0 ma, non essendoci alcuna ragione particolare per non farlo, si \u00e8 deciso di usare comunque interi a 8 byte.</p> <p>In ambiente di sviluppo</p> <p>SQLite non lavora bene con chiavi primarie come interi a 8 byte autoincrementanti. Pertanto, nell'ambiente di sviluppo, tutti gli ID sono effettivamente interi a 4 byte.</p>"},{"location":"2-architecture/#user","title":"User","text":"<p>Rappresenta un utente registrato, completo di username, email, e hash della password.</p>"},{"location":"2-architecture/#campi","title":"Campi","text":"<ul> <li>username: string(255), unique</li> <li>email: string(255), unique</li> <li>password_hash: string(255)</li> </ul>"},{"location":"2-architecture/#note","title":"Note","text":"<p>L'hash della password \u00e8 calcolato tramite Argon2id</p>"},{"location":"2-architecture/#api-token","title":"API Token","text":"<p>Rappresenta un token generato dall'utente per accedere alla propria API.</p> <p>Il singolo Token \u00e8 una stringa esadecimale casuale generata direttamente dal backend. La stringa \u00e8 lunga 32 caratteri esadecimali, che equivalgono ad un token da 16 byte.</p>"},{"location":"2-architecture/#service","title":"Service","text":"<p>Rappresenta un servizio monitorato da Downtime Panda.</p> <p>Vengono generati automaticamente alla prima iscrizione di un utente al servizio. Dalla seconda iscrizione in poi viene riusato lo stesso servizio.</p>"},{"location":"2-architecture/#ping","title":"Ping","text":"<p>Rappresenta il singolo ping/heartbeat mandato al servizio.</p> <p>In breve, salva la risposta HTTP ricevuta in un certo istante nel tempo.</p>"},{"location":"2-architecture/#subscription","title":"Subscription","text":"<p>Rappresenta l'iscrizione di un utente ad un servizio</p>"},{"location":"3-features/","title":"Principali Caratteristiche dell'Applicazione","text":"<p>In questa sezione sono elencate le principali caratteristiche dell'applicazione, che siano correlate alla sicurezza o meno.</p>"},{"location":"3-features/#generale","title":"Generale","text":""},{"location":"3-features/#ping-di-servizi","title":"Ping di servizi","text":"<p>Il principale servizio offerto dall'applicazione \u00e8 il monitoraggio dello stato di risorse o servizi in rete: l'utente chiede all'applicazione, ad esempio, di monitorare lo stato di un sito web, e questa far\u00e0, in background, richieste periodiche al sito web per verificarne lo stato.</p> <p>Questa feature \u00e8 implementata tramite il pacchetto APScheduler, gestito dall'estensione Flask-APScheduler.</p>"},{"location":"3-features/#versionamento-delle-migrazioni-del-db","title":"Versionamento delle Migrazioni del DB","text":"<p>Lo schema dell'intero DB \u00e8 versionato grazie all'uso di Alembic, gestito tramite l'estensione Flask-Migrate.</p> <p>La cartella <code>migrations/versions</code> versiona ogni modifica fatta allo schema del DB, in modo da poter ricreare lo stesso db ovunque.</p>"},{"location":"3-features/#ambiente-di-test-sviluppo-e-staging","title":"Ambiente di test, sviluppo e staging","text":"<p>Questo progetto offre tre ambienti diversi:</p> <ul> <li>Test: E' l'ambiente usato da <code>pytest</code> per far girare gli unit test. Fa uso di un database SQLite in memoria, unico per ogni singolo test.</li> <li>Sviluppo: E' l'ambiente per sviluppare. L'applicazione gira localmente su <code>localhost:8080</code>, \u00e8 abilitata al DEBUG e all'autorefresh dopo ogni modifica, e fa uso di un database <code>SQLite</code> creato automaticamente in <code>src/instance/dtpanda.db</code>. Il file del database \u00e8 ignorato da <code>git</code>.</li> <li>Staging: E' un ambiente che cerca di copiare un ambiente di produzione. Monta su non solo l'applicazione, ma anche un database Postgres e un Reverse Proxy con Caddy. Funziona grazie a <code>docker compose</code></li> </ul> <p>Per quanto non sia direttamente una feature di sicurezza, avere questi tre ambienti ha comunque un effetto indiretto sulla stessa:</p> <ul> <li>L'ambiente di test permette di verificare automaticamente il corretto funzionamento dell'applicazione, individuando eventuali regressioni e bug scaturiti dall'aggiunta di nuove feature.</li> <li>L'ambiente di sviluppo cerca di essere quanto meno oneroso nell'utilizzo da parte dello sviluppatore. Con i log di Debug abilitati e il refresh della pagina automatico dopo ogni nuova feature, si cerca di rendere lo sviluppo quanto pi\u00f9 rapido possibile.</li> <li>L'ambiente di staging offre un modo di testare l'applicazione in un ambiente simile a quello di produzione. L'idea \u00e8 cos\u00ec catturare problemi che non sarebbe possibile verificare durante il solo sviluppo (ad esempio, scaturiti dall'uso di un Reverse Proxy tra l'utente e l'applicazione)</li> </ul>"},{"location":"3-features/#test-tramite-pytest","title":"Test tramite PyTest","text":"<p>Per verificare il funzionamento dell'applicazione durante il suo sviluppo \u00e8 stato utilizzato <code>pytest</code>. Tramite questa libreria, \u00e8 possibile implementare degli unit-test per la nostra applicazione come delle semplici funzioni.</p> <p>Come gi\u00e0 detto nella sezione precedente, mettere su dei test automatici permette di catturare rapidamente bug e regressioni durante lo sviluppo.</p>"},{"location":"3-features/#pre-commit-task-e-mkdocs","title":"Pre-Commit, Task e MkDocs","text":"<p>Pi\u00f9 dei \"nice-to-have\" che delle vere e proprie funzionalit\u00e0 dell'applicazione, hanno comunque la loro utilit\u00e0:</p> <ul> <li>Pre-commit configura automaticamente dei git hooks, script eseguiti automaticamente all'atto di una commit. Utilissimi per formattare automaticamente il codice o anche controllare se vengono incluse informazioni sensibili tra i file di una commit.</li> <li>Task permette di dare un nome ad una serie di comandi usati di frequente, tramite la definizione di un <code>Taskfile</code>.</li> <li>MkDocs alimenta la documentazione che stai leggendo in questo momento ;).</li> </ul>"},{"location":"3-features/#sicurezza","title":"Sicurezza","text":""},{"location":"3-features/#gestione-dellutente","title":"Gestione dell'utente","text":"<p>Sul database, l'utente \u00e8 un record della tabella <code>User</code> che salva uno username, una email, e l'hash della sua password per effettuare il login. Questo \u00e8 stato gi\u00e0 delineato nella sezione Architettura.</p> <p>All'interno dell'applicazione Flask, l'utente \u00e8 gestito tramite l'estensione <code>Flask-Login</code>. L'estensione implementa la gestione dei cookie di sessione dell'utente, senza per\u00f2 imporre l'suo di un certo modello o rappresentazione per lo stesso.</p>"},{"location":"3-features/#registrazione","title":"Registrazione","text":"<p>La registrazione dell'utente avviene compilando un semplice form, composto da username, email, password ed una conferma password.</p> <p>La verifica del form \u00e8 lasciata a Flask-WTF, il quale fa sia semplici controlli (quali rendere i campi obbligatori o controllare la lunghezza della password) che controlli pi\u00f9 legati alla logica dell'applicazione (controllare che username ed email non siano gi\u00e0 stati usati da altri utenti).</p> <p>Nella registrazione, dalla password dell'utente viene ricavato il digest tramite l'algoritmo Argon2id, implementato tramite la libreria argon2-cffi.</p> <p>Se la registrazione va a buon fine, l'applicazione effettua automaticamente il login come \"cortesia\" all'utente.</p>"},{"location":"3-features/#login-e-logout","title":"Login e Logout","text":"<p>Come gi\u00e0 detto, l'autenticazione \u00e8 fornita da Flask-Login. L'implementazione \u00e8 relativamente semplice: Flask-Login si occupa di salvare l'id dell'utente in un cookie di sessione all'atto del login, mentre l'unica cosa che va fatta dal nostro lato \u00e8 specificare come recuperare un utente dato l'id dal cookie.</p> blueprints/user/routes.py<pre><code>from downtime_panda.extensions import login_manager\n\nfrom .models import User\n\n...\n\n@login_manager.user_loader\ndef user_loader(id: str):\n    id = int(id)\n    return User.get_by_id(id)\n</code></pre> <p>Flask-Login si appoggia alle sessioni di Flask. La sessione \u00e8 crittograficamente firmata tramite la FLASK_SECRET_KEY, che nel nostro caso \u00e8 impostata tramite variabili d'ambiente (vedi di pi\u00f9 nella sezione Configurazione Sicura)</p>"},{"location":"3-features/#monitoraggio-dei-servizi-ed-accesso-allapi-tramite-token","title":"Monitoraggio dei servizi ed accesso all'API tramite Token","text":"<p>Quando un utente decide di monitorare un servizio, questo inserisce il nome e l'uri del servizio che vuole monitorare. All'invio dei dati, downtime-panda fa una ricerca dell'uri fornito nel db per vedere se tale servizio \u00e8 stato gi\u00e0 registrato in passato.</p> <p>Un esito negativo porta alla registrazione dell'URI del servizio nella tabella <code>Service</code> del database, assieme alla creazione di un nuovo job in background tramite APScheduler. Questo job, ogni 5 secondi, manda una richiesta HTTP HEAD all'URI del relativo servizio e salva il risultato della richiesta nella tabella <code>Ping</code>.</p> <p>Un esito positivo semplicemente prende il riferimento a quel servizio, saltando tutta la fase elencata sopra.</p> <p>Avendo il servizio, il monitoraggio dello stesso da parte dell'utente viene registrato nella tabella <code>Subscriptions</code>. Oltre a contenere i riferimenti all'utente e al servizio, la tabella contiene anche la data di creazione del record, il nome dato dall'utente al servizio, ed un UUID generato per identificare l'iscrizione senza far riferimento all'ID del servizio stesso.</p> <p>L'utente a quel punto \u00e8 in grado di vedere lo stato del servizio accedendo alla rotta <code>/you/subscriptions/&lt;uuid&gt;</code>.</p>"},{"location":"3-features/#api-per-il-monitoraggio","title":"API per il monitoraggio","text":"<p>Con una iscrizione attiva, l'utente \u00e8 in grado di richiedere l'ultimo stato del servizio monitorato tramite l'API esposta alla rotta <code>/api/subscriptions/status</code>, fornendo un subscription_uuid come query parameter ed un token a suo nome nell'intestazione.</p> <p>La rotta ritorna le seguenti risposte:</p> <ul> <li>401 UNAUTHORIZED: Non \u00e8 stato fornito il token per l'autenticazione</li> <li>404 NOT FOUND: Non vi \u00e8 nessuna iscrizione con quell'uuid per l'utente con quel token, oppure non \u00e8 ancora stato fatto alcun ping al servizio.</li> <li>200 OK: Token e uuid sono corretti,ed \u00e8 stato fatto almeno un ping al servizio.</li> </ul> <p>Con i dati corretti, la rotta ritorna un file JSON contenente lo stato HTTP del servizio pi\u00f9 il timestamp dell'ultima richiesta fatta allo stesso.</p> <p>Ad esempio, una richiesta fatta con curl potrebbe essere fatta come segue...</p> <pre><code>curl --request GET \\\n  --url 'http://localhost:8080/api/subscriptions/status?subscription_uuid=00000000-0000-0000-0000-000000000000' \\\n  --header 'authorization: Bearer abcdefghijklmnopqrstuvwxyz123456'\n</code></pre> <p>...ed una possibile risposta potrebbe essere questa</p> <pre><code>{\n  \"http_response\": 200,\n  \"pinged_at\": \"2025-06-14T16:21:38.856451\",\n  \"response_time\": 0.2,\n}\n</code></pre> <p>Di seguito \u00e8 riportata una richiesta fatta correttamente al servizio, tramite il client Bruno.</p> <p>Figure 1: Una richiesta fatta correttamente all'API</p>"},{"location":"3-features/#token-e-autenticazione-con-lapi","title":"Token e autenticazione con l'API","text":"<p>Come detto sopra, l'utente ha bisogno di un token per autenticarsi con l'API.</p> <p>I token dell'utente autenticato vengono gestiti sulla rotta <code>/you/tokens</code>. Tramite gli appositi pulsanti, l'utente pu\u00f2 registrare o revocare token a suo nome.</p> <p>L'autenticazione con l'API \u00e8 implementata tramite l'estensione Flask-HTTPAuth, in particolare usando <code>TokenHTTPAuth</code>. L'autenticazione implementata dall'estensione \u00e8 di tipo Bearer: chiunque sia in possesso del token \u00e8 in grado di fare richieste all'API, senza dover fornire prova di essere il legittimo detentore della stringa.</p> <p>Nel fare la richiesta GET all'API \u00e8 necessario fornire il token nell'intestazione della richiesta. In particolare, va incluso nell'intestazione <code>Authorization</code>, nella forma <code>Bearer &lt;token&gt;</code>, come indicato sopra.</p>"},{"location":"3-features/#configurazione-sicura","title":"Configurazione sicura","text":"<p>Come consigliato per la Twelve-Factor App, la configurazione del codice andrebbe fatta usando le variabili d'ambiente del sistema che ospita l'app. In questo modo si evita di legare la configurazione al codice, e si evitano problemi comuni come includere dati sensibili nel Sistema di Controllo delle Versioni (VCS).</p> <p>Il file <code>config.py</code> contiene le classi che definiscono la configurazione dell'applicazione. L'uso di una classe per la configurazione dell'applicazione Flask \u00e8 una pratica documentata dai manutentori stessi.</p> <p>La classe <code>Config</code> viene caricata all'avvio dell'applicazione</p> __init__.py<pre><code>from flask import Flask\nfrom downtime_panda.config import Config\n\n...\n\ndef create_app(config_class=Config):\n    \"\"\"Create and configure the Flask application.\"\"\"\n    app = Flask(__name__)\n\n    ...\n\n    # ------------------------------- CONFIGURATION ------------------------------ #\n    logger.info(\"Setting up configuration...\")\n    app.config.from_object(config_class())\n</code></pre> <p>Una 'falla' voluta</p> <p>Si noti come, anche dopo quanto detto sopra, le configurazioni dell'applicazione nell'ambiente di staging siano codificate nel file <code>docker-compose.staging.yml</code>. In un vero ambiente di produzione, tale pratica sarebbe considerata ovviamente (e giustamente) una falla di sicurezza.</p> <p>In questo caso, per\u00f2, l'ambiente di staging \u00e8 stato pensato come una copia del possibile ambiente di produzione ma in locale. Per rendere la vita dello sviluppatore pi\u00f9 semplice, ogni servizio nel file \u00e8 gi\u00e0 preconfigurato in modo tale da funzionare da subito, fin dal primo <code>git clone</code>.</p> <p>Se questa cosa non va bene, \u00e8 sempre possibile sostituire la definizione delle variabili d'ambiente nel file <code>docker-compose.staging.yml</code> con un file <code>.env</code>: in questo modo si potrebbe mettere nel repository un file <code>.env.example</code>, che elenchi tutte le variabili d'ambiente in uso.</p> .env.example<pre><code>DTPANDA_SECRET_KEY=\nDTPANDA_DB_URL=\n...\n</code></pre> <p>Lo sviluppatore potr\u00e0 poi copiare tale definizione in un file <code>.env</code> dove configurare a proprio piacimento l'applicazione in locale.</p> <p>In questo caso, visto che l'ambiente di staging non \u00e8 pensato per essere messo direttamente in produzione, si \u00e8 optato per la soluzione pi\u00f9 comoda per lo sviluppatore.</p> <p>Una alternativa pi\u00f9 avanzata potrebbe far uso di un servizio separato per mantenere chiavi e segreti cifrati. Si veda la sezione Gestione della Configurazione pi\u00f9 Avanzata per maggiori dettagli.</p>"},{"location":"3-features/#deploy-come-container-docker","title":"Deploy come Container Docker","text":"<p>Docker \u00e8 una tecnologia per la containerizzazione di processi.</p> <p>Nel repository \u00e8 presente un <code>Dockerfile</code>, che descrive come costruire e mettere su l'applicazione.  Tale file viene elaborato da docker per creare una immagine, un pacchetto contenente sorgenti, librerie, e qualsiasi altra cosa richiesta dall'applicazione per funzionare. Infine, data una immagine, Docker pu\u00f2 mettere su un container, un processo eseguito in un ambiente isolato.</p> <p>Docker non aiuta soltanto isolando i container: grazie a Docker il deploy dell'applicazione \u00e8 veramente facile, dovendo solo costruire/recuperare l'immagine (in questo caso costruire, tramite <code>docker build</code>) ed avviare il container (<code>docker run</code>), o ancor pi\u00f9 facile utilizzando sistemi per l'orchestrazione dei container (ex. <code>docker compose</code>)</p>"},{"location":"3-features/#https","title":"HTTPS","text":"<p>L'accesso sicuro all'applicazione tramite HTTPS non \u00e8 gestito dall'applicazione stessa; bens\u00ec, nel <code>docker-compose.staging.yml</code> fornito \u00e8 montato su un Reverse Proxy, Caddy, che si occupa di elaborare, gestire ed instradare ogni richiesta proveniente dall'esterno verso la rete interna.</p> <p>Caddy genera di default un certificato autofirmato, che permette di comunicare in modo sicuro con HTTPS senza dover mettere su alcuna configurazione extra.</p> <p>Certificato autofirmato</p> <p>Essendo un certificato autofirmato da una Certificate Authority (CA) interna a Caddy, qualsiasi browser andr\u00e0 ad informare l'utente che la connessione in realt\u00e0 non \u00e8 privata, perch\u00e9 il certificato dell'ente certificatore non \u00e8 presente tra i certificati installati nella macchina e/o nel browser.</p> <p>La soluzione a questo problema \u00e8 semplice: basta prendere il certificato della CA dal container Caddy, ed installarlo sulla macchina locale.</p> <p>A questo scopo \u00e8 definito un task per recuperare e salvare in locale il certificato della CA di Caddy.</p> <pre><code>task staging-copy-cert\n</code></pre> <p>Contesto reale</p> <p>Ovviamente, in un contesto reale l'utilizzo di un certificato autofirmato \u00e8 inaccettabile. In un ambiente di produzione, quello che si dovrebbe fare sarebbe:</p> <ul> <li>Comprare/essere in possesso di un dominio</li> <li>Fare affidamento ad un ente certificatore (Ex. Let's Encrypt) per creare e rinnovare i certificati HTTPS per quel dominio.</li> </ul> <p>Di seguito \u00e8 mostrato come nell'ambiente di sviluppo sia possibile ricavare l'API token semplicemente sniffando il traffico HTTP tra il client ed il server.</p> <p>Figure 2: Cattura di pacchetti dell'API in HTTP, usando Wireshark</p> <p>Di seguito, invece, vi \u00e8 lo stesso tentativo di attacco, ma fatto nel contesto dell'ambiente di staging: la comunicazione presa di mira \u00e8 quella tra il client ed il reverse proxy Caddy.</p> <p>Figure 3: Cattura di pacchetti dell'API in HTTPS, usando Wireshark</p> <p>Traffico tra Proxy e Servizio</p> <p>E' bene precisare che comunque il traffico tra il reverse proxy ed il servizio (qui downtime-panda) rimane in HTTP. In un contesto isolato questo pu\u00f2 andare bene, ma un attaccante nella rete interna potrebbe tranquillamente intercettare traffico HTTP tra i container.</p>"},{"location":"4-future-developments/","title":"Sviluppi Futuri","text":""},{"location":"4-future-developments/#back-end-come-api-pura","title":"Back-End come API pura","text":"<p>Visto che l'applicazione espone una API per prendere gli ultimi token, una idea potrebbe essere dividere il Front-End ed il Back-End in due servizi separati:</p> <ul> <li>Il Back-End sarebbe puramente una API, scritta in Flask o anche in FastAPI.</li> <li>Il Front-End, gestito a parte ad esempio con node.js e npm, sarebbe giusto una interfaccia per fare chiamate all'API.</li> </ul> <p>I principali vantaggi di questa soluzione sarebbero:</p> <ul> <li>Semplificare il Back-End: Niente pi\u00f9 gestione di template Jinja, o di rotte separate per front-end ed API. Ogni rotta diverrebbe una chiamate API che ritorna, ad esempio, file JSON come risposta.</li> <li>Deploy separati: Si potrebbero mettere su e far evolvere i due servizi in modo separato, gestiti anche da team di sviluppo diversi. Inoltre, sarebbe pi\u00f9 facile creare interfacce alternative (ad esempio client desktop/mobile nativi, fatti anche da terze parti).</li> </ul>"},{"location":"4-future-developments/#servizi-pubblici-amministrazione","title":"Servizi Pubblici &amp; Amministrazione","text":"<p>L'idea originale era monitorare sia servizi \"pubblici\", consultabili anche da utenti non iscritti, che \"privati\", consultabili solo da utenti registrati, ma non \u00e8 stato possibile per mancanza di tempo.</p> <p>L'implementazione corrente supporta solamente i servizi \"privati\": gli utenti, tramite la loro iscrizione, cominciano a far monitorare una certa risorsa al servizio. In un certo senso, conoscere l'uri del servizio fa da chiave per poter accedere al monitoraggio dello stesso.</p> <p>La distinzione di servizi pubblici da privati introduce un problema che richiede una soluzione pi\u00f9 \"umana\" piuttosto che \"tecnologica\": Se un utente potesse scegliere di rendere un servizio monitorato da lui pubblico a tutti, niente vieterebbe ad un qualsiasi utente di rendere pubblico il servizio di qualcun'altro (ad esempio, un piccolo server a casa di qualcuno che \u00e8 semplicemente esposto all'esterno per uso personale).</p> <p>Pertanto, una tale distinzione andrebbe probabilmente risolta introducendo una parte di amministrazione nel sistema. Gli amministratori sarebbero coloro che decidono, eventualmente sotto richiesta di numerosi utenti, se rendere un servizio monitorato da downtime-panda \"pubblico\".</p>"},{"location":"4-future-developments/#notifiche-e-avvisi-di-downtime","title":"Notifiche e Avvisi di Downtime","text":"<p>Una feature molto utile sarebbe mandare avvisi di eventuali downtime dei servizi monitorati, tramite email o altro sistema (ad esempio ntfy.sh). Quando un servizio va offline, oppure torna online dopo un periodo di inattivit\u00e0, si potrebbe inviare un avviso a chiunque stia monitorando tale servizio.</p>"},{"location":"4-future-developments/#gestione-della-configurazione-piu-avanzata","title":"Gestione della Configurazione pi\u00f9 Avanzata","text":"<p>Come gi\u00e0 menzionato nelle sezioni precedenti, la configurazione del progetto \u00e8 gestita tramite variabili d'ambiente.</p> <p>Una alternativa a questa pratica \u00e8 l'utilizzo di un servizio separato per mantenere la configurazione del servizio, utilizzando ad esempio Hashicorp Vault. L'idea sarebbe mantenere i segreti dell'applicazione (quali credenziali del DB e chiavi di cifratura) in questo servizio, il quale salva queste informazioni su disco cifrate.</p> <p>L'applicazione dalle variabili d'ambiente dovr\u00e0 recuperare una ed una sola informazione: Il token per accedere al servizio di configurazione. Questo permette di:</p> <ul> <li>Ridurre il numero di segreti da gestire nelle variabili d'ambiente</li> <li>Implementare la rotazione dei segreti</li> <li>Si pu\u00f2 addirittura implementare la creazione ad-hoc dei segreti: ad esempio, creare \"al volo\" le credenziali di accesso al DB per l'applicazione</li> </ul> <p>Ovviamente, tale gestione non dovrebbe compromettere l'ambiente di sviluppo, che potrebbe continuare a funzionare con le variabili d'ambiente originali oppure con una versione \"falsata\" (mocked) del servizio.</p>"},{"location":"autoapi/summary/","title":"Summary","text":"<ul> <li>downtime_panda<ul> <li>blueprints<ul> <li>errors<ul> <li>routes</li> </ul> </li> <li>home<ul> <li>routes</li> </ul> </li> <li>service<ul> <li>models</li> <li>routes</li> </ul> </li> <li>subscription<ul> <li>api</li> <li>forms</li> <li>messages</li> <li>models</li> <li>routes</li> </ul> </li> <li>token<ul> <li>messages</li> <li>models</li> <li>routes</li> </ul> </li> <li>user<ul> <li>forms</li> <li>messages</li> <li>models</li> <li>routes</li> </ul> </li> </ul> </li> <li>config</li> <li>extensions</li> </ul> </li> </ul>"},{"location":"autoapi/downtime_panda/","title":"downtime_panda","text":"<p>Defines the Flask application factory for Downtime Panda.</p> exports <ul> <li>create_app: Function to create and configure the Flask application.</li> </ul>"},{"location":"autoapi/downtime_panda/#downtime_panda.create_app","title":"<code>create_app(config_class=Config)</code>","text":"<p>Create and configure the Flask application.</p> Source code in <code>src\\downtime_panda\\__init__.py</code> <pre><code>def create_app(config_class=Config):\n    \"\"\"Create and configure the Flask application.\"\"\"\n    app = Flask(__name__)\n\n    # ---------------------------------- LOGGING --------------------------------- #\n    class InterceptHandler(logging.Handler):\n        def emit(self, record):\n            # Retrieve context where the logging call occurred, this happens to be in the 6th frame upward\n            logger_opt = logger.opt(depth=6, exception=record.exc_info)\n            logger_opt.log(record.levelno, record.getMessage())\n\n    handler = InterceptHandler()\n    app.logger.addHandler(handler)\n\n    from flask.logging import default_handler\n\n    app.logger.removeHandler(default_handler)\n\n    # ------------------------------- CONFIGURATION ------------------------------ #\n    logger.info(\"Setting up configuration...\")\n    app.config.from_object(config_class())\n\n    # ---------------------------------- FILTERS --------------------------------- #\n    @app.template_filter()\n    def httpstatus(s):\n        from http.client import responses\n\n        return responses[s]\n\n    # -------------------------------- EXTENSIONS -------------------------------- #\n    logger.info(\"Initializing extensions...\")\n    extensions.login_manager.init_app(app)\n    extensions.db.init_app(app)\n    extensions.migrate.init_app(app, extensions.db)\n    with app.app_context():\n        app.config[\"SCHEDULER_JOBSTORES\"] = {\n            \"default\": SQLAlchemyJobStore(\n                engine=extensions.db.engine,\n                tablename=\"apscheduler_jobs\",\n            ),\n        }\n    extensions.scheduler.init_app(app)\n    extensions.moment.init_app(app)\n\n    with app.app_context():\n        logger.info(\"Creating database tables...\")\n        extensions.db.create_all()\n        if app.debug:\n            logger.info(\"Stamping...\")\n            stamp()\n\n    # -------------------------------- BLUEPRINTS -------------------------------- #\n    logger.info(\"Registering blueprints...\")\n    app.register_blueprint(home_blueprint, url_prefix=\"/\")\n    app.register_blueprint(auth_blueprint, url_prefix=\"/auth\")\n    app.register_blueprint(user_blueprint, url_prefix=\"/you\")\n    app.register_blueprint(service_blueprint, url_prefix=\"/service\")\n    app.register_blueprint(subscription_api_blueprint, url_prefix=\"/api/subscriptions\")\n    app.register_blueprint(subscription_blueprint, url_prefix=\"/you/subscriptions\")\n    app.register_blueprint(token_blueprint, url_prefix=\"/you/tokens\")\n\n    # -------------------------- SCHEDULER CONFIGURATION ------------------------- #\n    if (\n        not (app.debug or app.config[\"DEBUG\"])\n        or os.environ.get(\"WERKZEUG_RUN_MAIN\") == \"true\"\n    ):\n        logger.info(\"Starting APScheduler...\")\n        extensions.scheduler.start()\n        logger.info(extensions.scheduler.scheduler._jobstores)\n\n    logger.info(\"Downtime Panda application configured successfully.\")\n    return app\n</code></pre>"},{"location":"autoapi/downtime_panda/config/","title":"config","text":"<p>This module contains both Flask configuration and application constants for Downtime Panda.</p> exports <ul> <li>Config: Configuration class for the Downtime Panda application.</li> <li>TestingConfig: Configuration class for testing environment.</li> </ul>"},{"location":"autoapi/downtime_panda/config/#downtime_panda.config.Config","title":"<code>Config</code>","text":"<p>Configuration class for the Downtime Panda application. This class holds configuration settings such as debug mode, database URL, and secret key.</p> Source code in <code>src\\downtime_panda\\config.py</code> <pre><code>class Config:\n    \"\"\"\n    Configuration class for the Downtime Panda application.\n    This class holds configuration settings such as debug mode, database URL, and secret key.\n    \"\"\"\n\n    DEBUG = os.getenv(\"DTPANDA_DEBUG\", \"false\").lower() in (\"true\", \"1\", \"yes\")\n    \"\"\"\n    Indicates whether the application is running in debug mode.\n    Set to True if the environment variable 'DTPANDA_DEBUG' is set to 'true', '1', or 'yes' (case-insensitive).\n    \"\"\"\n\n    SQLALCHEMY_DATABASE_URI = (\n        f\"postgresql+psycopg://{os.getenv('DTPANDA_DB_URL')}\"\n        if os.getenv(\"DTPANDA_DB_URL\")\n        else \"sqlite:///dtpanda.db\"\n    )\n    \"\"\"\n    The database connection URL for the database, constructed from the environment variable 'DTPANDA_DB_URL'.\n\n    Defaults to a SQLite database file named `dtpanda.db` if the environment variable is not set, which is saved inside the `src/instance` directory.\n    \"\"\"\n\n    SECRET_KEY = os.getenv(\"DTPANDA_SECRET_KEY\") or \"a_very_secret_key\"\n    \"\"\"\n    The secret key used by Flask for cryptographic operations (e.g., session signing).\n    Loaded from the environment variable 'DTPANDA_SECRET'.\n    \"\"\"\n\n    # -------------------------------- APSCHEDULER ------------------------------- #\n    SCHEDULER_JOBSTORES = {\n        \"default\": SQLAlchemyJobStore(\n            url=SQLALCHEMY_DATABASE_URI\n            if os.getenv(\"DTPANDA_DB_URL\")\n            else \"sqlite:///src/instance/dtpanda.db\",\n            tablename=\"apscheduler_jobs\",\n        ),\n    }\n    \"\"\"\n    Configuration for the APScheduler job store.\n    \"\"\"\n\n    SCHEDULER_TIMEZONE = pytz.utc\n    \"\"\"\n    The timezone used by the APScheduler.\n    Set to UTC by default.\n    \"\"\"\n</code></pre>"},{"location":"autoapi/downtime_panda/config/#downtime_panda.config.Config.DEBUG","title":"<code>DEBUG = os.getenv('DTPANDA_DEBUG', 'false').lower() in ('true', '1', 'yes')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates whether the application is running in debug mode. Set to True if the environment variable 'DTPANDA_DEBUG' is set to 'true', '1', or 'yes' (case-insensitive).</p>"},{"location":"autoapi/downtime_panda/config/#downtime_panda.config.Config.SCHEDULER_JOBSTORES","title":"<code>SCHEDULER_JOBSTORES = {'default': SQLAlchemyJobStore(url=SQLALCHEMY_DATABASE_URI if os.getenv('DTPANDA_DB_URL') else 'sqlite:///src/instance/dtpanda.db', tablename='apscheduler_jobs')}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration for the APScheduler job store.</p>"},{"location":"autoapi/downtime_panda/config/#downtime_panda.config.Config.SCHEDULER_TIMEZONE","title":"<code>SCHEDULER_TIMEZONE = pytz.utc</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The timezone used by the APScheduler. Set to UTC by default.</p>"},{"location":"autoapi/downtime_panda/config/#downtime_panda.config.Config.SECRET_KEY","title":"<code>SECRET_KEY = os.getenv('DTPANDA_SECRET_KEY') or 'a_very_secret_key'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The secret key used by Flask for cryptographic operations (e.g., session signing). Loaded from the environment variable 'DTPANDA_SECRET'.</p>"},{"location":"autoapi/downtime_panda/config/#downtime_panda.config.Config.SQLALCHEMY_DATABASE_URI","title":"<code>SQLALCHEMY_DATABASE_URI = f'postgresql+psycopg://{os.getenv('DTPANDA_DB_URL')}' if os.getenv('DTPANDA_DB_URL') else 'sqlite:///dtpanda.db'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The database connection URL for the database, constructed from the environment variable 'DTPANDA_DB_URL'.</p> <p>Defaults to a SQLite database file named <code>dtpanda.db</code> if the environment variable is not set, which is saved inside the <code>src/instance</code> directory.</p>"},{"location":"autoapi/downtime_panda/config/#downtime_panda.config.TestingConfig","title":"<code>TestingConfig</code>","text":"<p>               Bases: <code>Config</code></p> <p>Configuration class for testing environment. Inherits from Config and overrides specific settings for testing.</p> Source code in <code>src\\downtime_panda\\config.py</code> <pre><code>class TestingConfig(Config):\n    \"\"\"\n    Configuration class for testing environment.\n    Inherits from Config and overrides specific settings for testing.\n    \"\"\"\n\n    DEBUG = True\n    \"\"\"\n    Enables debug mode for testing.\n    \"\"\"\n\n    SQLALCHEMY_DATABASE_URI = \"sqlite:///:memory:\"\n    \"\"\"\n    Uses an in-memory SQLite database for testing purposes.\n    This allows for fast tests without needing a persistent database.\n    \"\"\"\n\n    TESTING = True\n    \"\"\"\n    Indicates that the application is in testing mode.\n    This can enable additional testing features or behaviors.\n    \"\"\"\n\n    WTF_CSRF_ENABLED = False\n    \"\"\"\n    Disables CSRF protection for testing.\n    This is often done in tests to simplify form submissions.\n    \"\"\"\n</code></pre>"},{"location":"autoapi/downtime_panda/config/#downtime_panda.config.TestingConfig.DEBUG","title":"<code>DEBUG = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enables debug mode for testing.</p>"},{"location":"autoapi/downtime_panda/config/#downtime_panda.config.TestingConfig.SQLALCHEMY_DATABASE_URI","title":"<code>SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Uses an in-memory SQLite database for testing purposes. This allows for fast tests without needing a persistent database.</p>"},{"location":"autoapi/downtime_panda/config/#downtime_panda.config.TestingConfig.TESTING","title":"<code>TESTING = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates that the application is in testing mode. This can enable additional testing features or behaviors.</p>"},{"location":"autoapi/downtime_panda/config/#downtime_panda.config.TestingConfig.WTF_CSRF_ENABLED","title":"<code>WTF_CSRF_ENABLED = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Disables CSRF protection for testing. This is often done in tests to simplify form submissions.</p>"},{"location":"autoapi/downtime_panda/extensions/","title":"extensions","text":"<p>This module contains all extensions for the Flask application.</p>"},{"location":"autoapi/downtime_panda/blueprints/","title":"blueprints","text":"<p>This package contains the blueprints for the Downtime Panda application.</p>"},{"location":"autoapi/downtime_panda/blueprints/errors/","title":"errors","text":""},{"location":"autoapi/downtime_panda/blueprints/errors/routes/","title":"routes","text":""},{"location":"autoapi/downtime_panda/blueprints/errors/routes/#downtime_panda.blueprints.errors.routes.forbidden_error","title":"<code>forbidden_error(error)</code>","text":"<p>Handle 403 Forbidden errors.</p> Source code in <code>src\\downtime_panda\\blueprints\\errors\\routes.py</code> <pre><code>@error_blueprint.app_errorhandler(403)\ndef forbidden_error(error):\n    \"\"\"\n    Handle 403 Forbidden errors.\n    \"\"\"\n    return {\"error\": \"Forbidden\"}, 403\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/errors/routes/#downtime_panda.blueprints.errors.routes.internal_server_error","title":"<code>internal_server_error(error)</code>","text":"<p>Handle 500 Internal Server Error.</p> Source code in <code>src\\downtime_panda\\blueprints\\errors\\routes.py</code> <pre><code>@error_blueprint.app_errorhandler(500)\ndef internal_server_error(error):\n    \"\"\"\n    Handle 500 Internal Server Error.\n    \"\"\"\n    return {\"error\": \"Internal Server Error\"}, 500\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/errors/routes/#downtime_panda.blueprints.errors.routes.not_found_error","title":"<code>not_found_error(error)</code>","text":"<p>Handle 404 Not Found errors.</p> Source code in <code>src\\downtime_panda\\blueprints\\errors\\routes.py</code> <pre><code>@error_blueprint.app_errorhandler(404)\ndef not_found_error(error):\n    \"\"\"\n    Handle 404 Not Found errors.\n    \"\"\"\n    return {\"error\": \"Not Found\"}, 404\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/home/","title":"home","text":""},{"location":"autoapi/downtime_panda/blueprints/home/routes/","title":"routes","text":""},{"location":"autoapi/downtime_panda/blueprints/home/routes/#downtime_panda.blueprints.home.routes.index","title":"<code>index()</code>","text":"<p>Render the home page.</p> Source code in <code>src\\downtime_panda\\blueprints\\home\\routes.py</code> <pre><code>@home_blueprint.route(\"/\")\ndef index() -&gt; str:\n    \"\"\"Render the home page.\"\"\"\n    return render_template(\"blueprints/index.html.jinja\")\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/service/","title":"service","text":"<p>This module defines the service blueprint and models for Downtime Panda's service management.</p>"},{"location":"autoapi/downtime_panda/blueprints/service/models/","title":"models","text":""},{"location":"autoapi/downtime_panda/blueprints/service/models/#downtime_panda.blueprints.service.models.Ping","title":"<code>Ping</code>","text":"<p>               Bases: <code>Model</code></p> <p>Ping model to store service ping data.</p> Source code in <code>src\\downtime_panda\\blueprints\\service\\models.py</code> <pre><code>class Ping(db.Model):\n    \"\"\"Ping model to store service ping data.\"\"\"\n\n    __tablename__ = \"ping\"\n    # ---------------------------------- COLUMNS --------------------------------- #\n    id: Mapped[int] = mapped_column(\n        BigInteger().with_variant(Integer, \"sqlite\"), primary_key=True\n    )\n    service_id: Mapped[int] = mapped_column(\n        ForeignKey(Service.id, onupdate=\"CASCADE\", ondelete=\"RESTRICT\"), nullable=False\n    )\n    http_response: Mapped[int] = mapped_column(Integer(), nullable=False)\n    response_time: Mapped[timedelta] = mapped_column(Interval(), nullable=False)\n    pinged_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)\n\n    # ----------------------------- STANDARD METHODS ----------------------------- #\n    def __init__(\n        self,\n        service_id: int,\n        http_status: int,\n        response_time: timedelta,\n        pinged_at: datetime,\n    ):\n        self.service_id = service_id\n        self.http_response = http_status\n        self.response_time = response_time\n        self.pinged_at = pinged_at\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Ping {self.id} for Service {self.service_id}&gt;\"\n\n    # ---------------------------------- METHODS --------------------------------- #\n    def to_dict(self) -&gt; dict[str, Any]:\n        return {\n            \"http_response\": self.http_response,\n            \"response_time\": self.response_time.total_seconds(),\n            \"pinged_at\": self.pinged_at.isoformat(),\n        }\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/service/models/#downtime_panda.blueprints.service.models.Service","title":"<code>Service</code>","text":"<p>               Bases: <code>Model</code></p> <p>Service model to store service information and related pings.</p> Source code in <code>src\\downtime_panda\\blueprints\\service\\models.py</code> <pre><code>class Service(db.Model):\n    \"\"\"Service model to store service information and related pings.\"\"\"\n\n    __tablename__ = \"service\"\n    # ---------------------------------- COLUMNS --------------------------------- #\n    id: Mapped[int] = mapped_column(\n        BigInteger().with_variant(Integer, \"sqlite\"), primary_key=True\n    )\n    uri: Mapped[str] = mapped_column(String(255), nullable=False, unique=True)\n\n    # ------------------------------- RELATIONSHIPS ------------------------------ #\n    ping: WriteOnlyMapped[\"Ping\"] = relationship(order_by=\"Ping.pinged_at.desc()\")\n\n    # ----------------------------- STANDARD METHODS ----------------------------- #\n    def __init__(self, uri: str):\n        self.uri = uri\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Service {self.id}&gt;\"\n\n    # -------------------------------- CONSTRUCTOR ------------------------------- #\n    @classmethod\n    def create_if_not_exists(cls, uri: str) -&gt; Self:\n        \"\"\"Create a new service if it does not already exist.\"\"\"\n        if cls.uri_exists(uri):\n            return cls.get_by_uri(uri)\n\n        service = Service(\n            uri=uri,\n        )\n        db.session.add(service)\n        db.session.commit()\n        db.session.refresh(service)\n\n        # Schedule the ping job for the new service\n        trigger = IntervalTrigger(seconds=5)\n        scheduler.add_job(\n            func=service.ping_service,\n            args=[service.id],\n            trigger=trigger,\n            replace_existing=True,\n            id=f\"ping_service_{service.id}\",\n        )\n\n        db.session.commit()\n        return service\n\n    @classmethod\n    def get_by_uri(cls, uri: str) -&gt; Self | None:\n        \"\"\"Get a service by its URI, or None if it does not exist.\"\"\"\n        return db.session.execute(select(cls).filter_by(uri=uri)).scalar_one_or_none()\n\n    @classmethod\n    def uri_exists(cls, uri: str) -&gt; bool:\n        \"\"\"Checks if a service with the specified URI exists.\"\"\"\n        return cls.get_by_uri(uri=uri) is not None\n\n    @classmethod\n    def ping_service(cls, service_id: int) -&gt; None:\n        with scheduler.app.app_context():\n            service = db.session.get(cls, service_id)\n            logger.info(service)\n\n            pinged_at = datetime.now(pytz.utc)\n            try:\n                response = requests.head(service.uri, allow_redirects=True)\n\n                status_code = response.status_code\n                response_time = response.elapsed\n            except requests.exceptions.ConnectionError:\n                response_time = timedelta(seconds=-1)\n                status_code = NOT_FOUND\n\n            ping = Ping(\n                service_id=f\"ping_service_{service.id}\",\n                http_status=status_code,\n                response_time=response_time,\n                pinged_at=pinged_at,\n            )\n            service.ping.add(ping)\n            db.session.commit()\n\n    def get_latest_ping(self) -&gt; \"Ping | None\":\n        \"\"\"Get the latest ping for the service.\"\"\"\n        return db.session.execute(\n            select(Ping).filter_by(service_id=self.id).order_by(Ping.pinged_at.desc())\n        ).scalar()\n\n    def get_latest_n_pings(self, n: int) -&gt; Sequence[\"Ping\"]:\n        query = (\n            select(Ping)\n            .filter_by(service_id=self.id)\n            .order_by(Ping.pinged_at.desc())\n            .limit(n)\n        )\n        return db.session.execute(query).scalars().all()\n\n    def get_pings_since(self, since: datetime) -&gt; Sequence[\"Ping\"]:\n        query = (\n            select(Ping)\n            .filter_by(service_id=self.id)\n            .where(Ping.pinged_at &gt;= since)\n            .order_by(Ping.pinged_at.desc())\n        )\n        return db.session.execute(query).scalars().all()\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/service/models/#downtime_panda.blueprints.service.models.Service.create_if_not_exists","title":"<code>create_if_not_exists(uri)</code>  <code>classmethod</code>","text":"<p>Create a new service if it does not already exist.</p> Source code in <code>src\\downtime_panda\\blueprints\\service\\models.py</code> <pre><code>@classmethod\ndef create_if_not_exists(cls, uri: str) -&gt; Self:\n    \"\"\"Create a new service if it does not already exist.\"\"\"\n    if cls.uri_exists(uri):\n        return cls.get_by_uri(uri)\n\n    service = Service(\n        uri=uri,\n    )\n    db.session.add(service)\n    db.session.commit()\n    db.session.refresh(service)\n\n    # Schedule the ping job for the new service\n    trigger = IntervalTrigger(seconds=5)\n    scheduler.add_job(\n        func=service.ping_service,\n        args=[service.id],\n        trigger=trigger,\n        replace_existing=True,\n        id=f\"ping_service_{service.id}\",\n    )\n\n    db.session.commit()\n    return service\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/service/models/#downtime_panda.blueprints.service.models.Service.get_by_uri","title":"<code>get_by_uri(uri)</code>  <code>classmethod</code>","text":"<p>Get a service by its URI, or None if it does not exist.</p> Source code in <code>src\\downtime_panda\\blueprints\\service\\models.py</code> <pre><code>@classmethod\ndef get_by_uri(cls, uri: str) -&gt; Self | None:\n    \"\"\"Get a service by its URI, or None if it does not exist.\"\"\"\n    return db.session.execute(select(cls).filter_by(uri=uri)).scalar_one_or_none()\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/service/models/#downtime_panda.blueprints.service.models.Service.get_latest_ping","title":"<code>get_latest_ping()</code>","text":"<p>Get the latest ping for the service.</p> Source code in <code>src\\downtime_panda\\blueprints\\service\\models.py</code> <pre><code>def get_latest_ping(self) -&gt; \"Ping | None\":\n    \"\"\"Get the latest ping for the service.\"\"\"\n    return db.session.execute(\n        select(Ping).filter_by(service_id=self.id).order_by(Ping.pinged_at.desc())\n    ).scalar()\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/service/models/#downtime_panda.blueprints.service.models.Service.uri_exists","title":"<code>uri_exists(uri)</code>  <code>classmethod</code>","text":"<p>Checks if a service with the specified URI exists.</p> Source code in <code>src\\downtime_panda\\blueprints\\service\\models.py</code> <pre><code>@classmethod\ndef uri_exists(cls, uri: str) -&gt; bool:\n    \"\"\"Checks if a service with the specified URI exists.\"\"\"\n    return cls.get_by_uri(uri=uri) is not None\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/service/routes/","title":"routes","text":""},{"location":"autoapi/downtime_panda/blueprints/subscription/","title":"subscription","text":""},{"location":"autoapi/downtime_panda/blueprints/subscription/api/","title":"api","text":""},{"location":"autoapi/downtime_panda/blueprints/subscription/api/#downtime_panda.blueprints.subscription.api.get_status","title":"<code>get_status()</code>","text":"<p>Endpoint to check the status of a subscription.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the status of the subscription.</p> Source code in <code>src\\downtime_panda\\blueprints\\subscription\\api.py</code> <pre><code>@subscription_api_blueprint.get(\"/status\")\n@token_auth.login_required\ndef get_status():\n    \"\"\"\n    Endpoint to check the status of a subscription.\n\n    Returns:\n        dict: A dictionary containing the status of the subscription.\n    \"\"\"\n    user: User | None = token_auth.current_user()\n    if not user:\n        abort(HTTPStatus.UNAUTHORIZED)\n\n    subscription_uuid = request.args.get(\"subscription_uuid\")\n\n    subscription = Subscription.get_user_subscription_by_uuid(user, subscription_uuid)\n    if not subscription:\n        abort(\n            HTTPStatus.NOT_FOUND,\n            description=\"Subscription not found.\",\n        )\n\n    latest_ping = subscription.service.get_latest_ping()\n    if not latest_ping:\n        abort(HTTPStatus.NOT_FOUND, description=\"No pings found for the service.\")\n\n    return latest_ping.to_dict()\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/subscription/api/#downtime_panda.blueprints.subscription.api.heartbeat","title":"<code>heartbeat()</code>","text":"<p>Endpoint to check if the service API is running.</p> Source code in <code>src\\downtime_panda\\blueprints\\subscription\\api.py</code> <pre><code>@subscription_api_blueprint.get(\"/heartbeat\")\ndef heartbeat():\n    \"\"\"\n    Endpoint to check if the service API is running.\n    \"\"\"\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/subscription/forms/","title":"forms","text":""},{"location":"autoapi/downtime_panda/blueprints/subscription/messages/","title":"messages","text":""},{"location":"autoapi/downtime_panda/blueprints/subscription/models/","title":"models","text":""},{"location":"autoapi/downtime_panda/blueprints/subscription/models/#downtime_panda.blueprints.subscription.models.Subscription","title":"<code>Subscription</code>","text":"<p>               Bases: <code>Model</code></p> Source code in <code>src\\downtime_panda\\blueprints\\subscription\\models.py</code> <pre><code>class Subscription(db.Model):\n    __tablename__ = \"subscription\"\n\n    # ---------------------------------- COLUMNS --------------------------------- #\n    user_id: Mapped[int] = mapped_column(\n        ForeignKey(\"user.id\"),\n        primary_key=True,\n    )\n    service_id: Mapped[int] = mapped_column(ForeignKey(\"service.id\"), primary_key=True)\n    name: Mapped[str] = mapped_column(\n        String(255),\n        nullable=False,\n        index=False,\n        unique=False,\n    )\n    created_at: Mapped[DateTime] = mapped_column(\n        DateTime(timezone=True), nullable=False, server_default=func.now()\n    )\n    uuid: Mapped[str] = mapped_column(\n        Uuid(),\n        index=True,\n        nullable=False,\n        unique=True,\n        default=uuid.uuid4,\n    )\n\n    # ------------------------------- RELATIONSHIPS ------------------------------ #\n    user: Mapped[\"User\"] = db.relationship(\"User\", back_populates=\"subscriptions\")\n    service: Mapped[\"Service\"] = db.relationship(\"Service\")\n\n    # ----------------------------- STANDARD METHODS ----------------------------- #\n    def __init__(self, user_id: int, service_id: int, name: str):\n        self.user_id = user_id\n        self.service_id = service_id\n        self.name = name\n\n    def __repr__(self):\n        return f\"&lt;Subscription {self.id}&gt;\"\n\n    # ------------------------------- CONSTRUCTORS ------------------------------- #\n    @classmethod\n    def subscribe_user_to_service(\n        cls, user: \"User\", service: \"Service\", name: str\n    ) -&gt; Self:\n        \"\"\"Create a new subscription for a user to a service.\"\"\"\n        subscription = cls(user_id=user.id, service_id=service.id, name=name)\n        db.session.add(subscription)\n        db.session.commit()\n        return subscription\n\n    @classmethod\n    def get_subscriptions_by_user(cls, user: \"User\") -&gt; list[Self]:\n        \"\"\"Get all subscriptions for a user.\"\"\"\n        query = select(cls).filter_by(user_id=user.id)\n        subscriptions = db.session.execute(query).scalars().all()\n        return subscriptions\n\n    @classmethod\n    def get_user_subscription_by_uuid(cls, user: \"User\", sub_uuid: str) -&gt; Self | None:\n        sub_uuid = uuid.UUID(sub_uuid)\n        query = select(cls).filter_by(user_id=user.id, uuid=sub_uuid)\n        subscription = db.session.execute(query).scalars().one_or_none()\n        return subscription\n\n    def get_latest_http_response(self) -&gt; int | None:\n        latest_ping = self.service.get_latest_ping()\n        return latest_ping.http_response if latest_ping else None\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/subscription/models/#downtime_panda.blueprints.subscription.models.Subscription.get_subscriptions_by_user","title":"<code>get_subscriptions_by_user(user)</code>  <code>classmethod</code>","text":"<p>Get all subscriptions for a user.</p> Source code in <code>src\\downtime_panda\\blueprints\\subscription\\models.py</code> <pre><code>@classmethod\ndef get_subscriptions_by_user(cls, user: \"User\") -&gt; list[Self]:\n    \"\"\"Get all subscriptions for a user.\"\"\"\n    query = select(cls).filter_by(user_id=user.id)\n    subscriptions = db.session.execute(query).scalars().all()\n    return subscriptions\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/subscription/models/#downtime_panda.blueprints.subscription.models.Subscription.subscribe_user_to_service","title":"<code>subscribe_user_to_service(user, service, name)</code>  <code>classmethod</code>","text":"<p>Create a new subscription for a user to a service.</p> Source code in <code>src\\downtime_panda\\blueprints\\subscription\\models.py</code> <pre><code>@classmethod\ndef subscribe_user_to_service(\n    cls, user: \"User\", service: \"Service\", name: str\n) -&gt; Self:\n    \"\"\"Create a new subscription for a user to a service.\"\"\"\n    subscription = cls(user_id=user.id, service_id=service.id, name=name)\n    db.session.add(subscription)\n    db.session.commit()\n    return subscription\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/subscription/routes/","title":"routes","text":""},{"location":"autoapi/downtime_panda/blueprints/subscription/routes/#downtime_panda.blueprints.subscription.routes.get_subscription_pings_since","title":"<code>get_subscription_pings_since(uuid)</code>","text":"<p>View the status of a subscribed service</p> Source code in <code>src\\downtime_panda\\blueprints\\subscription\\routes.py</code> <pre><code>@subscription_blueprint.route(\"/&lt;uuid&gt;/pings_since\", methods=[\"GET\"])\n@login_required\ndef get_subscription_pings_since(uuid: str):\n    \"\"\"View the status of a subscribed service\"\"\"\n    subscription = Subscription.get_user_subscription_by_uuid(current_user, uuid)\n\n    since_date = datetime.fromisoformat(request.args[\"since\"])\n    pings = subscription.service.get_pings_since(since_date)\n    pings = list(reversed(pings))\n    pings = {\n        \"x\": [ping.pinged_at for ping in pings],\n        \"y\": [ping.response_time.total_seconds() for ping in pings],\n        \"status\": [ping.http_response for ping in pings],\n        \"type\": \"scatter\",\n    }\n    return pings\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/subscription/routes/#downtime_panda.blueprints.subscription.routes.list_subscriptions","title":"<code>list_subscriptions()</code>","text":"<p>List all subscriptions for the current user.</p> Source code in <code>src\\downtime_panda\\blueprints\\subscription\\routes.py</code> <pre><code>@subscription_blueprint.route(\"/\", methods=[\"GET\"])\n@login_required\ndef list_subscriptions():\n    \"\"\"List all subscriptions for the current user.\"\"\"\n    subscriptions = Subscription.get_subscriptions_by_user(current_user)\n    return render_template(\n        \"blueprints/subscription/list.html.jinja\",\n        subscriptions=subscriptions,\n    )\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/subscription/routes/#downtime_panda.blueprints.subscription.routes.view_subscription","title":"<code>view_subscription(uuid)</code>","text":"<p>View the status of a subscribed service</p> Source code in <code>src\\downtime_panda\\blueprints\\subscription\\routes.py</code> <pre><code>@subscription_blueprint.route(\"/&lt;uuid&gt;\", methods=[\"GET\"])\n@login_required\ndef view_subscription(uuid: str):\n    \"\"\"View the status of a subscribed service\"\"\"\n    MAX_POINTS = 20\n    subscription = Subscription.get_user_subscription_by_uuid(current_user, uuid)\n    pings = subscription.service.get_latest_n_pings(MAX_POINTS)\n    pings = list(reversed(pings))\n    pings = {\n        \"x\": [ping.pinged_at for ping in pings],\n        \"y\": [ping.response_time.total_seconds() for ping in pings],\n        \"status\": [ping.http_response for ping in pings],\n        \"type\": \"scatter\",\n    }\n    return render_template(\n        \"blueprints/subscription/status.html.jinja\",\n        subscription=subscription,\n        pings=pings,\n        max_points=MAX_POINTS,\n    )\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/token/","title":"token","text":"<p>Test</p>"},{"location":"autoapi/downtime_panda/blueprints/token/#downtime_panda.blueprints.token.APIToken","title":"<code>APIToken</code>","text":"<p>               Bases: <code>Model</code></p> <p>Model for API tokens associated with users.</p> Source code in <code>src\\downtime_panda\\blueprints\\token\\models.py</code> <pre><code>class APIToken(db.Model):\n    \"\"\"Model for API tokens associated with users.\"\"\"\n\n    __tablename__ = \"api_token\"\n\n    # ---------------------------------- COLUMNS --------------------------------- #\n    id: Mapped[int] = mapped_column(\n        BigInteger().with_variant(Integer(), \"sqlite\"), primary_key=True\n    )\n    user_id: Mapped[int] = mapped_column(\n        BigInteger(),\n        ForeignKey(\"user.id\"),\n        nullable=False,\n    )\n    token: Mapped[str] = mapped_column(\n        String(32),\n        unique=True,\n        nullable=False,\n    )\n    created_at: Mapped[DateTime] = mapped_column(\n        DateTime(timezone=True),\n        nullable=False,\n        server_default=func.now(),\n    )\n\n    # ------------------------------- RELATIONSHIPS ------------------------------ #\n    user: Mapped[\"User\"] = relationship(\n        \"User\",\n        back_populates=\"api_tokens\",\n    )\n\n    # ----------------------------- STANDARD METHODS ----------------------------- #\n    def __init__(self, user_id: int, token: str):\n        self.user_id = user_id\n        self.token = token\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;APIToken {self.id} for User {self.user_id}&gt;\"\n\n    # ------------------------------- CONSTRUCTORS ------------------------------- #\n    @classmethod\n    def create_for_user(cls, user: \"User\") -&gt; Self:\n        \"\"\"\n        Create a new API token for the user.\n        \"\"\"\n\n        token = APIToken(user_id=user.id, token=secrets.token_hex(16))\n        db.session.add(token)\n        db.session.commit()\n\n        return token\n\n    @classmethod\n    def find_by_id(cls, token_id: int, user: \"User\") -&gt; Self | None:\n        \"\"\"Finds a token by ID.\n\n        Args:\n            id (int): The token's ID\n            user (User): The user who generated the token\n\n        Returns:\n            Self: The token, or `None` if not found\n        \"\"\"\n        query = select(APIToken).filter_by(id=token_id, user_id=user.id)\n        token = db.session.execute(query).scalar()\n        return token\n\n    def revoke(self) -&gt; None:\n        \"\"\"\n        Revoke this API token.\n        \"\"\"\n\n        db.session.delete(self)\n        db.session.commit()\n\n    def exists(self) -&gt; bool:\n        query = select(APIToken).filter_by(id=self.id)\n        token = db.session.execute(query).scalar_one_or_none()\n        return True if token else False\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/token/#downtime_panda.blueprints.token.APIToken.create_for_user","title":"<code>create_for_user(user)</code>  <code>classmethod</code>","text":"<p>Create a new API token for the user.</p> Source code in <code>src\\downtime_panda\\blueprints\\token\\models.py</code> <pre><code>@classmethod\ndef create_for_user(cls, user: \"User\") -&gt; Self:\n    \"\"\"\n    Create a new API token for the user.\n    \"\"\"\n\n    token = APIToken(user_id=user.id, token=secrets.token_hex(16))\n    db.session.add(token)\n    db.session.commit()\n\n    return token\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/token/#downtime_panda.blueprints.token.APIToken.find_by_id","title":"<code>find_by_id(token_id, user)</code>  <code>classmethod</code>","text":"<p>Finds a token by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The token's ID</p> required <code>user</code> <code>User</code> <p>The user who generated the token</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self | None</code> <p>The token, or <code>None</code> if not found</p> Source code in <code>src\\downtime_panda\\blueprints\\token\\models.py</code> <pre><code>@classmethod\ndef find_by_id(cls, token_id: int, user: \"User\") -&gt; Self | None:\n    \"\"\"Finds a token by ID.\n\n    Args:\n        id (int): The token's ID\n        user (User): The user who generated the token\n\n    Returns:\n        Self: The token, or `None` if not found\n    \"\"\"\n    query = select(APIToken).filter_by(id=token_id, user_id=user.id)\n    token = db.session.execute(query).scalar()\n    return token\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/token/#downtime_panda.blueprints.token.APIToken.revoke","title":"<code>revoke()</code>","text":"<p>Revoke this API token.</p> Source code in <code>src\\downtime_panda\\blueprints\\token\\models.py</code> <pre><code>def revoke(self) -&gt; None:\n    \"\"\"\n    Revoke this API token.\n    \"\"\"\n\n    db.session.delete(self)\n    db.session.commit()\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/token/messages/","title":"messages","text":""},{"location":"autoapi/downtime_panda/blueprints/token/models/","title":"models","text":""},{"location":"autoapi/downtime_panda/blueprints/token/models/#downtime_panda.blueprints.token.models.APIToken","title":"<code>APIToken</code>","text":"<p>               Bases: <code>Model</code></p> <p>Model for API tokens associated with users.</p> Source code in <code>src\\downtime_panda\\blueprints\\token\\models.py</code> <pre><code>class APIToken(db.Model):\n    \"\"\"Model for API tokens associated with users.\"\"\"\n\n    __tablename__ = \"api_token\"\n\n    # ---------------------------------- COLUMNS --------------------------------- #\n    id: Mapped[int] = mapped_column(\n        BigInteger().with_variant(Integer(), \"sqlite\"), primary_key=True\n    )\n    user_id: Mapped[int] = mapped_column(\n        BigInteger(),\n        ForeignKey(\"user.id\"),\n        nullable=False,\n    )\n    token: Mapped[str] = mapped_column(\n        String(32),\n        unique=True,\n        nullable=False,\n    )\n    created_at: Mapped[DateTime] = mapped_column(\n        DateTime(timezone=True),\n        nullable=False,\n        server_default=func.now(),\n    )\n\n    # ------------------------------- RELATIONSHIPS ------------------------------ #\n    user: Mapped[\"User\"] = relationship(\n        \"User\",\n        back_populates=\"api_tokens\",\n    )\n\n    # ----------------------------- STANDARD METHODS ----------------------------- #\n    def __init__(self, user_id: int, token: str):\n        self.user_id = user_id\n        self.token = token\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;APIToken {self.id} for User {self.user_id}&gt;\"\n\n    # ------------------------------- CONSTRUCTORS ------------------------------- #\n    @classmethod\n    def create_for_user(cls, user: \"User\") -&gt; Self:\n        \"\"\"\n        Create a new API token for the user.\n        \"\"\"\n\n        token = APIToken(user_id=user.id, token=secrets.token_hex(16))\n        db.session.add(token)\n        db.session.commit()\n\n        return token\n\n    @classmethod\n    def find_by_id(cls, token_id: int, user: \"User\") -&gt; Self | None:\n        \"\"\"Finds a token by ID.\n\n        Args:\n            id (int): The token's ID\n            user (User): The user who generated the token\n\n        Returns:\n            Self: The token, or `None` if not found\n        \"\"\"\n        query = select(APIToken).filter_by(id=token_id, user_id=user.id)\n        token = db.session.execute(query).scalar()\n        return token\n\n    def revoke(self) -&gt; None:\n        \"\"\"\n        Revoke this API token.\n        \"\"\"\n\n        db.session.delete(self)\n        db.session.commit()\n\n    def exists(self) -&gt; bool:\n        query = select(APIToken).filter_by(id=self.id)\n        token = db.session.execute(query).scalar_one_or_none()\n        return True if token else False\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/token/models/#downtime_panda.blueprints.token.models.APIToken.create_for_user","title":"<code>create_for_user(user)</code>  <code>classmethod</code>","text":"<p>Create a new API token for the user.</p> Source code in <code>src\\downtime_panda\\blueprints\\token\\models.py</code> <pre><code>@classmethod\ndef create_for_user(cls, user: \"User\") -&gt; Self:\n    \"\"\"\n    Create a new API token for the user.\n    \"\"\"\n\n    token = APIToken(user_id=user.id, token=secrets.token_hex(16))\n    db.session.add(token)\n    db.session.commit()\n\n    return token\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/token/models/#downtime_panda.blueprints.token.models.APIToken.find_by_id","title":"<code>find_by_id(token_id, user)</code>  <code>classmethod</code>","text":"<p>Finds a token by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The token's ID</p> required <code>user</code> <code>User</code> <p>The user who generated the token</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self | None</code> <p>The token, or <code>None</code> if not found</p> Source code in <code>src\\downtime_panda\\blueprints\\token\\models.py</code> <pre><code>@classmethod\ndef find_by_id(cls, token_id: int, user: \"User\") -&gt; Self | None:\n    \"\"\"Finds a token by ID.\n\n    Args:\n        id (int): The token's ID\n        user (User): The user who generated the token\n\n    Returns:\n        Self: The token, or `None` if not found\n    \"\"\"\n    query = select(APIToken).filter_by(id=token_id, user_id=user.id)\n    token = db.session.execute(query).scalar()\n    return token\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/token/models/#downtime_panda.blueprints.token.models.APIToken.revoke","title":"<code>revoke()</code>","text":"<p>Revoke this API token.</p> Source code in <code>src\\downtime_panda\\blueprints\\token\\models.py</code> <pre><code>def revoke(self) -&gt; None:\n    \"\"\"\n    Revoke this API token.\n    \"\"\"\n\n    db.session.delete(self)\n    db.session.commit()\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/token/routes/","title":"routes","text":""},{"location":"autoapi/downtime_panda/blueprints/token/routes/#downtime_panda.blueprints.token.routes.generate_token","title":"<code>generate_token()</code>","text":"<p>Create a new API token for the user.</p> Source code in <code>src\\downtime_panda\\blueprints\\token\\routes.py</code> <pre><code>@token_blueprint.post(\"/generate\")\n@flask_login.login_required\ndef generate_token():\n    \"\"\"Create a new API token for the user.\"\"\"\n\n    APIToken.create_for_user(flask_login.current_user)\n    flash(SUCCESS_TOKEN_CREATED, \"success\")\n    return redirect(url_for(\".list_tokens\"))\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/token/routes/#downtime_panda.blueprints.token.routes.list_tokens","title":"<code>list_tokens()</code>","text":"<p>Display the user's API tokens.</p> Source code in <code>src\\downtime_panda\\blueprints\\token\\routes.py</code> <pre><code>@token_blueprint.get(\"/\")\n@flask_login.login_required\ndef list_tokens():\n    \"\"\"Display the user's API tokens.\"\"\"\n\n    return render_template(\"blueprints/token/list.html.jinja\")\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/token/routes/#downtime_panda.blueprints.token.routes.revoke_token","title":"<code>revoke_token(token_id)</code>","text":"<p>Delete an API token.</p> Source code in <code>src\\downtime_panda\\blueprints\\token\\routes.py</code> <pre><code>@token_blueprint.post(\"/revoke/&lt;int:token_id&gt;\")\n@flask_login.login_required\ndef revoke_token(token_id: int):\n    \"\"\"Delete an API token.\"\"\"\n\n    token = APIToken.find_by_id(token_id=token_id, user=flask_login.current_user)\n    if not token:\n        flash(ERROR_TOKEN_DOESNT_EXIST, \"danger\")\n        return redirect(url_for(\".list_tokens\"), code=HTTPStatus.NOT_FOUND)\n\n    token.revoke()\n    flash(SUCCESS_TOKEN_REVOKED, \"success\")\n    return redirect(url_for(\".list_tokens\"))\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/","title":"user","text":"<p>The user package provides functionality related to user management, including user views and blueprints for integration with the main application.</p>"},{"location":"autoapi/downtime_panda/blueprints/user/forms/","title":"forms","text":""},{"location":"autoapi/downtime_panda/blueprints/user/forms/#downtime_panda.blueprints.user.forms.LoginForm","title":"<code>LoginForm</code>","text":"<p>               Bases: <code>FlaskForm</code></p> <p>Form to login the user</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\forms.py</code> <pre><code>class LoginForm(FlaskForm):\n    \"\"\"Form to login the user\"\"\"\n\n    email = StringField(\n        \"Email\",\n        description=\"Email\",\n        validators=[DataRequired(ERROR_EMAIL_REQUIRED), Email(ERROR_EMAIL_NOT_VALID)],\n    )\n    password = PasswordField(\n        \"Password\",\n        description=\"Password\",\n        validators=[\n            DataRequired(ERROR_PASSWORD_REQUIRED),\n        ],\n    )\n    remember_me = BooleanField(\"Remember Me\", description=\"Remember Me\")\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/forms/#downtime_panda.blueprints.user.forms.RegisterForm","title":"<code>RegisterForm</code>","text":"<p>               Bases: <code>FlaskForm</code></p> <p>The Registration form to register a new user to the app.</p> <p>The form handles both simple checks (like making all fields required), as well as business logic checks (like checking if the username/email is taken).</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\forms.py</code> <pre><code>class RegisterForm(FlaskForm):\n    \"\"\"\n    The Registration form to register a new user to the app.\n\n    The form handles both simple checks (like making all fields required), as\n    well as business logic checks (like checking if the username/email is taken).\n    \"\"\"\n\n    username = StringField(\n        \"Username\",\n        description=\"Username\",\n        validators=[DataRequired(ERROR_USERNAME_REQUIRED), username_is_free],\n    )\n    email = StringField(\n        \"Email\",\n        description=\"Email\",\n        validators=[\n            DataRequired(ERROR_EMAIL_REQUIRED),\n            Email(ERROR_EMAIL_NOT_VALID),\n            email_is_free,\n        ],\n    )\n    password = PasswordField(\n        \"Password\",\n        description=\"Password\",\n        validators=[\n            DataRequired(ERROR_PASSWORD_REQUIRED),\n            Length(min=8, message=ERROR_PASSWORD_TOO_SHORT),\n        ],\n    )\n    confirm_password = PasswordField(\n        \"Confirm Password\",\n        description=\"Confirm password\",\n        validators=[\n            DataRequired(ERROR_PASSWORD_REQUIRED),\n            Length(min=8, message=ERROR_PASSWORD_TOO_SHORT),\n            EqualTo(\"password\", message=ERROR_PASSWORD_MISMATCH),\n        ],\n    )\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/forms/#downtime_panda.blueprints.user.forms.email_is_free","title":"<code>email_is_free(form, field)</code>","text":"<p>Checks if the supplied email is already presentin the database</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\forms.py</code> <pre><code>def email_is_free(form, field):\n    \"\"\"Checks if the supplied email is already presentin the database\"\"\"\n    if User.email_exists(field.data):\n        raise ValidationError(ERROR_EMAIL_TAKEN)\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/forms/#downtime_panda.blueprints.user.forms.username_is_free","title":"<code>username_is_free(form, field)</code>","text":"<p>Checks if the supplied username is already present in the database</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\forms.py</code> <pre><code>def username_is_free(form, field):\n    \"\"\"Checks if the supplied username is already present in the database\"\"\"\n    if User.username_exists(field.data):\n        raise ValidationError(ERROR_USERNAME_TAKEN)\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/messages/","title":"messages","text":""},{"location":"autoapi/downtime_panda/blueprints/user/models/","title":"models","text":""},{"location":"autoapi/downtime_panda/blueprints/user/models/#downtime_panda.blueprints.user.models.User","title":"<code>User</code>","text":"<p>               Bases: <code>Model</code>, <code>UserMixin</code></p> <p>User model for authentication and user management.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\models.py</code> <pre><code>class User(db.Model, flask_login.UserMixin):\n    \"\"\"User model for authentication and user management.\"\"\"\n\n    __tablename__ = \"user\"\n\n    # ---------------------------------- COLUMNS --------------------------------- #\n    id: Mapped[int] = mapped_column(\n        BigInteger().with_variant(Integer, \"sqlite\"), primary_key=True\n    )\n    username: Mapped[str] = mapped_column(String(255), unique=True)\n    email: Mapped[str] = mapped_column(String(255), unique=True)\n    password_hash: Mapped[str] = mapped_column(String(255))\n\n    # ------------------------------- RELATIONSHIPS ------------------------------ #\n    subscriptions: Mapped[list[\"Subscription\"]] = relationship(\n        \"Subscription\", back_populates=\"user\", cascade=\"all, delete-orphan\"\n    )\n    api_tokens: Mapped[list[\"APIToken\"]] = relationship(\n        \"APIToken\",\n        back_populates=\"user\",\n    )\n\n    # ----------------------------- STANDARD METHODS ----------------------------- #\n    def __init__(self, username: str, email: str, password_hash: str):\n        self.username = username\n        self.email = email\n        self.password_hash = password_hash\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;User {self.id}&gt;\"\n\n    # -------------------------------- CONSTRUCTOR ------------------------------- #\n    @classmethod\n    def register(cls, username: str, email: str, password: str) -&gt; Self:\n        \"\"\"Add a new user to the database.\n\n        Args:\n            username (str): Username of the user\n            email (str): Email of the user\n            password (str): Password of the user\n\n        Raises:\n            ValueError: If the username or email already exists in the database\n\n        Returns:\n            Self: The created user instance\n        \"\"\"\n        ph = PasswordHasher()\n        password_hash = ph.hash(password)\n\n        user = cls(username=username, email=email, password_hash=password_hash)\n        db.session.add(user)\n        db.session.commit()\n        return user\n\n    # ---------------------------------- METHODS --------------------------------- #\n    @classmethod\n    def username_exists(cls, username: str) -&gt; bool:\n        \"\"\"Check if a username already exists in the database.\"\"\"\n        return (\n            db.session.execute(select(cls).filter_by(username=username)).first()\n            is not None\n        )\n\n    @classmethod\n    def email_exists(cls, email: str) -&gt; bool:\n        \"\"\"Check if an email already exists in the database.\"\"\"\n        return (\n            db.session.execute(select(cls).filter_by(email=email)).first() is not None\n        )\n\n    @classmethod\n    def get_by_id(cls, user_id: int) -&gt; Self | None:\n        \"\"\"Retrieve a user by their ID.\"\"\"\n        return db.session.get(cls, user_id)\n\n    @classmethod\n    def get_by_username(cls, username: str) -&gt; Self | None:\n        \"\"\"Retrieve a user by their username.\"\"\"\n        return db.session.query(cls).filter_by(username=username).first()\n\n    @classmethod\n    def get_by_email(cls, email: str) -&gt; Self | None:\n        \"\"\"Retrieve a user by their email.\"\"\"\n        return db.session.query(cls).filter_by(email=email).first()\n\n    def verify_password(self, password: str) -&gt; bool:\n        \"\"\"Verify the provided password against the stored hash, and rehash if necessary.\"\"\"\n        ph = PasswordHasher()\n        try:\n            ph.verify(self.password_hash, password)\n\n            if ph.check_needs_rehash(self.password_hash):\n                # Rehash the password if needed\n                self.password_hash = ph.hash(password)\n                db.session.commit()\n\n            return True\n        except Exception:\n            return False\n\n    def subscribe_to_service(self, service: \"Service\") -&gt; None:\n        \"\"\"Subscribe the user to a service.\"\"\"\n        if service not in self.services:\n            self.services.append(service)\n            db.session.commit()\n\n    def create_token(self):\n        \"\"\"Create a new API token for the user.\"\"\"\n        token = APIToken(user_id=self.id, token=secrets.token_hex(16))\n        self.api_tokens.append(token)\n        db.session.commit()\n\n    def revoke_token(self, token_id: int) -&gt; None:\n        \"\"\"Revoke an API token for the user.\"\"\"\n        token_to_remove = db.session.execute(\n            select(APIToken).filter_by(id=token_id, user_id=self.id)\n        ).scalar_one_or_none()\n\n        if not token_to_remove:\n            raise ValueError(\n                f\"Token with ID {token_id} does not exist or does not belong to the user.\"\n            )\n\n        db.session.delete(token_to_remove)\n        db.session.commit()\n\n    @classmethod\n    def get_by_token(cls, token: str) -&gt; Self | None:\n        \"\"\"Validate an API token and return the associated user if valid.\"\"\"\n\n        api_token = db.session.query(APIToken).filter_by(token=token).first()\n        if api_token:\n            return api_token.user\n        return None\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/models/#downtime_panda.blueprints.user.models.User.create_token","title":"<code>create_token()</code>","text":"<p>Create a new API token for the user.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\models.py</code> <pre><code>def create_token(self):\n    \"\"\"Create a new API token for the user.\"\"\"\n    token = APIToken(user_id=self.id, token=secrets.token_hex(16))\n    self.api_tokens.append(token)\n    db.session.commit()\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/models/#downtime_panda.blueprints.user.models.User.email_exists","title":"<code>email_exists(email)</code>  <code>classmethod</code>","text":"<p>Check if an email already exists in the database.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\models.py</code> <pre><code>@classmethod\ndef email_exists(cls, email: str) -&gt; bool:\n    \"\"\"Check if an email already exists in the database.\"\"\"\n    return (\n        db.session.execute(select(cls).filter_by(email=email)).first() is not None\n    )\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/models/#downtime_panda.blueprints.user.models.User.get_by_email","title":"<code>get_by_email(email)</code>  <code>classmethod</code>","text":"<p>Retrieve a user by their email.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\models.py</code> <pre><code>@classmethod\ndef get_by_email(cls, email: str) -&gt; Self | None:\n    \"\"\"Retrieve a user by their email.\"\"\"\n    return db.session.query(cls).filter_by(email=email).first()\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/models/#downtime_panda.blueprints.user.models.User.get_by_id","title":"<code>get_by_id(user_id)</code>  <code>classmethod</code>","text":"<p>Retrieve a user by their ID.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\models.py</code> <pre><code>@classmethod\ndef get_by_id(cls, user_id: int) -&gt; Self | None:\n    \"\"\"Retrieve a user by their ID.\"\"\"\n    return db.session.get(cls, user_id)\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/models/#downtime_panda.blueprints.user.models.User.get_by_token","title":"<code>get_by_token(token)</code>  <code>classmethod</code>","text":"<p>Validate an API token and return the associated user if valid.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\models.py</code> <pre><code>@classmethod\ndef get_by_token(cls, token: str) -&gt; Self | None:\n    \"\"\"Validate an API token and return the associated user if valid.\"\"\"\n\n    api_token = db.session.query(APIToken).filter_by(token=token).first()\n    if api_token:\n        return api_token.user\n    return None\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/models/#downtime_panda.blueprints.user.models.User.get_by_username","title":"<code>get_by_username(username)</code>  <code>classmethod</code>","text":"<p>Retrieve a user by their username.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\models.py</code> <pre><code>@classmethod\ndef get_by_username(cls, username: str) -&gt; Self | None:\n    \"\"\"Retrieve a user by their username.\"\"\"\n    return db.session.query(cls).filter_by(username=username).first()\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/models/#downtime_panda.blueprints.user.models.User.register","title":"<code>register(username, email, password)</code>  <code>classmethod</code>","text":"<p>Add a new user to the database.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>Username of the user</p> required <code>email</code> <code>str</code> <p>Email of the user</p> required <code>password</code> <code>str</code> <p>Password of the user</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the username or email already exists in the database</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The created user instance</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\models.py</code> <pre><code>@classmethod\ndef register(cls, username: str, email: str, password: str) -&gt; Self:\n    \"\"\"Add a new user to the database.\n\n    Args:\n        username (str): Username of the user\n        email (str): Email of the user\n        password (str): Password of the user\n\n    Raises:\n        ValueError: If the username or email already exists in the database\n\n    Returns:\n        Self: The created user instance\n    \"\"\"\n    ph = PasswordHasher()\n    password_hash = ph.hash(password)\n\n    user = cls(username=username, email=email, password_hash=password_hash)\n    db.session.add(user)\n    db.session.commit()\n    return user\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/models/#downtime_panda.blueprints.user.models.User.revoke_token","title":"<code>revoke_token(token_id)</code>","text":"<p>Revoke an API token for the user.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\models.py</code> <pre><code>def revoke_token(self, token_id: int) -&gt; None:\n    \"\"\"Revoke an API token for the user.\"\"\"\n    token_to_remove = db.session.execute(\n        select(APIToken).filter_by(id=token_id, user_id=self.id)\n    ).scalar_one_or_none()\n\n    if not token_to_remove:\n        raise ValueError(\n            f\"Token with ID {token_id} does not exist or does not belong to the user.\"\n        )\n\n    db.session.delete(token_to_remove)\n    db.session.commit()\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/models/#downtime_panda.blueprints.user.models.User.subscribe_to_service","title":"<code>subscribe_to_service(service)</code>","text":"<p>Subscribe the user to a service.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\models.py</code> <pre><code>def subscribe_to_service(self, service: \"Service\") -&gt; None:\n    \"\"\"Subscribe the user to a service.\"\"\"\n    if service not in self.services:\n        self.services.append(service)\n        db.session.commit()\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/models/#downtime_panda.blueprints.user.models.User.username_exists","title":"<code>username_exists(username)</code>  <code>classmethod</code>","text":"<p>Check if a username already exists in the database.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\models.py</code> <pre><code>@classmethod\ndef username_exists(cls, username: str) -&gt; bool:\n    \"\"\"Check if a username already exists in the database.\"\"\"\n    return (\n        db.session.execute(select(cls).filter_by(username=username)).first()\n        is not None\n    )\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/models/#downtime_panda.blueprints.user.models.User.verify_password","title":"<code>verify_password(password)</code>","text":"<p>Verify the provided password against the stored hash, and rehash if necessary.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\models.py</code> <pre><code>def verify_password(self, password: str) -&gt; bool:\n    \"\"\"Verify the provided password against the stored hash, and rehash if necessary.\"\"\"\n    ph = PasswordHasher()\n    try:\n        ph.verify(self.password_hash, password)\n\n        if ph.check_needs_rehash(self.password_hash):\n            # Rehash the password if needed\n            self.password_hash = ph.hash(password)\n            db.session.commit()\n\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/routes/","title":"routes","text":"<p>User management routes for Downtime Panda.</p> <p>This module handles user registration, login, logout, profile management, and API token management.</p>"},{"location":"autoapi/downtime_panda/blueprints/user/routes/#downtime_panda.blueprints.user.routes.login","title":"<code>login()</code>","text":"<p>Log in an existing user.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\routes.py</code> <pre><code>@auth_blueprint.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    \"\"\"Log in an existing user.\"\"\"\n    form = LoginForm()\n    if not form.validate_on_submit():\n        return render_template(\"blueprints/user/login.html.jinja\", form=form)\n\n    user = User.get_by_email(form.email.data)\n    if user and user.verify_password(form.password.data):\n        flask_login.login_user(user, remember=form.remember_me.data)\n        flash(SUCCESS_LOGIN, \"success\")\n        return redirect(url_for(\"home.index\"))\n\n    flash(ERROR_INVALID_CREDENTIALS, \"danger\")\n    return render_template(\"blueprints/user/login.html.jinja\", form=form)\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/routes/#downtime_panda.blueprints.user.routes.logout","title":"<code>logout()</code>","text":"<p>Log out the current user.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\routes.py</code> <pre><code>@auth_blueprint.route(\"/logout\", methods=[\"POST\"])\ndef logout():\n    \"\"\"Log out the current user.\"\"\"\n    if flask_login.current_user.is_authenticated:\n        flask_login.logout_user()\n        flash(SUCCESS_LOGOUT, \"success\")\n    return redirect(url_for(\"home.index\"))\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/routes/#downtime_panda.blueprints.user.routes.register","title":"<code>register()</code>","text":"<p>Register a new user.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\routes.py</code> <pre><code>@auth_blueprint.route(\"/register\", methods=[\"GET\", \"POST\"])\ndef register():\n    \"\"\"Register a new user.\"\"\"\n    form = RegisterForm()\n    if not form.validate_on_submit():\n        return render_template(\"blueprints/user/register.html.jinja\", form=form)\n\n    try:\n        User.register(\n            username=form.username.data,\n            email=form.email.data,\n            password=form.password.data,\n        )\n    except ValueError as e:\n        flash(\"Error: \" + str(e), \"error\")\n        return render_template(\n            \"blueprints/user/register.html.jinja\", form=form, error=str(e)\n        )\n\n    user = User.get_by_email(form.email.data)\n    flask_login.login_user(user)\n\n    flash(SUCCESS_REGISTRATION, \"success\")\n    return redirect(url_for(\"home.index\"))\n</code></pre>"},{"location":"autoapi/downtime_panda/blueprints/user/routes/#downtime_panda.blueprints.user.routes.show_profile","title":"<code>show_profile()</code>","text":"<p>Display the user's profile.</p> Source code in <code>src\\downtime_panda\\blueprints\\user\\routes.py</code> <pre><code>@user_blueprint.route(\"/profile\")\n@flask_login.login_required\ndef show_profile():\n    \"\"\"Display the user's profile.\"\"\"\n    return render_template(\"blueprints/user/profile.html.jinja\")\n</code></pre>"}]}